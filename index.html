<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Micro:bit Adventure | Beating Heart Project</title>
<style>
:root {
    --primary: #5E81F4;
    --secondary: #FF7AC6;
    --accent: #FFB800;
    --light: #F5F7FA;
    --dark: #1A1D28;
    --success: #7CE7AC;
    --danger: #FF7E7E; /* Added for incorrect options */
}
body {
    font-family: 'Comic Sans MS', 'Segoe UI', sans-serif;
    margin: 0;
    padding: 0;
    background-color: var(--light);
    color: var(--dark);
    line-height: 1.6;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 15px;
}

.project-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px; /* Reduced gap */
    margin-bottom: 20px;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    padding: 20px; /* Increased padding */
    border-radius: 15px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    text-align: center;
    position: relative;
}

.project-header img {
    width: 100px; /* Adjusted size */
    height: auto;
    border-radius: 10px;
    border: 3px solid white;
}

.project-title-container {
    flex-grow: 1;
}

.project-title {
    color: white;
    margin: 0 0 5px 0; /* Added bottom margin */
    font-size: 1.6rem; /* Slightly larger */
    text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
}

.project-subtitle {
     color: rgba(255, 255, 255, 0.9);
     font-size: 0.95rem;
     margin: 0;
}

.tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 15px;
    overflow-x: auto;
    padding-bottom: 5px;
    -webkit-overflow-scrolling: touch;
}

.tabs::-webkit-scrollbar {
    display: none;
}

.tab {
    padding: 8px 15px;
    background-color: white;
    border-radius: 30px;
    cursor: pointer;
    font-weight: bold;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    white-space: nowrap;
    font-size: 0.9rem;
    flex-shrink: 0;
    transition: background-color 0.3s, color 0.3s;
}

.tab.active {
    background-color: var(--primary);
    color: white;
}
.tab:hover:not(.active) {
    background-color: #eef2ff;
}

.tab-content {
    display: none;
    background-color: white;
    padding: 20px;
    border-radius: 15px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    animation: fadeIn 0.5s;
    margin-bottom: 20px;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.tab-content.active {
    display: block;
}

h2 {
    color: var(--primary);
    border-bottom: 3px solid var(--secondary);
    padding-bottom: 8px;
    display: inline-block;
    font-size: 1.3rem;
    margin-top: 0;
    margin-bottom: 20px; /* Added margin */
}
h3 {
    color: var(--dark);
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 1.1rem;
}

.video-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    margin: 15px 0;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Added shadow */
}

.video-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 10px;
    border: none; /* Removed border */
}

.slide {
    display: none;
    text-align: center; /* Center slide content */
}

.slideshow {
    position: relative;
    margin: 15px 0;
    background-color: #f9f9ff; /* Light background for slideshow area */
    padding: 15px;
    border-radius: 10px;
}

.slide-content-wrapper {
    position: relative;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
    height: 0;
    overflow: hidden;
    margin: 0 auto 15px auto; /* Center wrapper and add bottom margin */
    max-width: 100%;
    background-color: #eee; /* Placeholder background */
    border-radius: 8px;
}

.slide iframe, .slide img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: contain; /* Ensure entire content is visible */
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    background-color: transparent; /* Let wrapper background show */
}

.slide p {
    margin: 10px 0 0;
    font-size: 0.9rem;
    color: #555; /* Slightly muted text color */
}

.slide.active {
    display: block;
    animation: fadeIn 0.5s;
}

.slide-nav {
    text-align: center;
    margin-top: 15px;
    display: flex;
    justify-content: center;
    gap: 10px;
}

.slide-nav button {
    background-color: var(--primary);
    color: white;
    border: none;
    padding: 8px 16px; /* Increased padding */
    border-radius: 20px; /* Rounded buttons */
    cursor: pointer;
    font-size: 0.9rem; /* Increased size */
    transition: background-color 0.3s;
}
.slide-nav button:hover {
    background-color: #4a6cdc; /* Darker primary on hover */
}


.step {
    display: flex;
    gap: 15px;
    margin-bottom: 15px;
    padding: 15px;
    background-color: #f9f9ff;
    border-radius: 10px;
    align-items: flex-start;
    border-left: 4px solid var(--secondary); /* Accent border */
}

.step-number {
    background-color: var(--secondary);
    color: white;
    min-width: 30px; /* Use min-width */
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    flex-shrink: 0;
    font-size: 0.9rem;
}

.step-content {
    flex: 1;
}

.step-content strong {
    font-size: 1rem; /* Slightly larger */
    color: var(--primary); /* Use primary color */
    display: block; /* Ensure it takes full width */
    margin-bottom: 3px; /* Spacing */
}

.step-content p {
    margin: 0; /* Remove default margin */
    font-size: 0.9rem;
    color: #333; /* Darker grey */
}

/* --- Quiz Specific Styles --- */
.quiz-question {
    background-color: #fdfdff; /* Slightly off-white */
    padding: 20px;
    margin-bottom: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(94, 129, 244, 0.1); /* Subtle shadow */
    border: 1px solid #e0e8ff; /* Light border */
}

.quiz-question p.question-text { /* Style for the question text itself */
    margin: 0 0 15px; /* Increased bottom margin */
    font-size: 1rem;
    font-weight: bold; /* Make question bold */
    color: var(--dark);
}

.quiz-options {
    margin-top: 10px;
    display: flex;          /* Use flexbox */
    flex-direction: column; /* Stack options vertically */
    gap: 8px;               /* Add space between options */
}

.quiz-option {
    display: block;
    padding: 12px 15px; /* More padding */
    margin-bottom: 0; /* Remove margin, use gap instead */
    background-color: #f5f7fa; /* Lighter background */
    border: 1px solid #d8dde6; /* Softer border */
    border-radius: 8px; /* More rounded corners */
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
    position: relative; /* Needed for pseudo-elements if added later */
    text-align: left; /* Ensure text aligns left */
    /* Default state - before submit */
    opacity: 1;
}

.quiz-option:hover {
    background-color: #e8ecf3;
    border-color: #c4cde0;
}

/* Styles applied *after* submit */
.quiz-option.selected {
    /* Style for the option the user actually picked */
    /* background-color: var(--primary); */ /* Base selection color might be confusing after submit */
    /* color: white; */
    /* border-color: var(--primary); */
}

.quiz-option.correct {
    /* Style applied to the CORRECT option after submit, regardless of selection */
    background-color: var(--success);
    color: white;
    border-color: #63c899;
    font-weight: bold;
}
.quiz-option.correct.selected {
     /* If the user SELECTED the correct one, ensure correct style dominates */
    background-color: var(--success);
    color: white;
    border-color: #63c899;
}


.quiz-option.incorrect.selected {
    /* Style applied ONLY if the user SELECTED an INCORRECT option */
    background-color: var(--danger);
    color: white;
    border-color: #e66a6a;
    font-weight: bold; /* Optionally bold their wrong choice */
     text-decoration: line-through; /* Strike through wrong selection */
     text-decoration-thickness: 2px;
}

/* Dim unselected options after submit */
.quiz-question.answered .quiz-option:not(.selected):not(.correct) {
    opacity: 0.6;
    cursor: default;
    background-color: #f5f7fa; /* Reset background */
    border-color: #d8dde6; /* Reset border */
}
/* Ensure the correct unselected option isn't dimmed */
.quiz-question.answered .quiz-option.correct:not(.selected) {
     opacity: 1;
}


.quiz-feedback {
    margin-top: 12px;
    padding: 10px 15px; /* Adjusted padding */
    border-radius: 5px;
    display: none; /* Initially hidden */
    font-size: 0.85rem;
    border-width: 1px;
    border-style: solid;
}

.quiz-feedback.correct {
    background-color: #e6f7ed;
    color: #1d6c45; /* Darker green */
    border-color: #c3e6cb;
    /* display: block; <- Handled by JS on submit */
}

.quiz-feedback.incorrect {
    background-color: #fde8e8;
    color: #9b1c1c; /* Darker red */
    border-color: #f5c6cb;
     /* display: block; <- Handled by JS on submit */
}

/* Final result div styling (added by export script) */
.final-quiz-result {
    margin-top: 20px;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    font-weight: bold;
    font-size: 1.1rem;
}
.final-quiz-result.success {
    background-color: #e6f7ed;
    color: #1d6c45;
    border: 1px solid #c3e6cb;
}
.final-quiz-result.fail {
    background-color: #fde8e8;
    color: #9b1c1c;
    border: 1px solid #f5c6cb;
}


.submit-btn {
    background-color: var(--accent);
    color: var(--dark); /* Dark text on yellow */
    border: none;
    padding: 12px 25px; /* More padding */
    border-radius: 30px;
    font-weight: bold;
    cursor: pointer;
    margin-top: 25px; /* More space above */
    font-size: 1rem; /* Larger font */
    transition: all 0.3s;
    display: block;
    width: 100%;
    max-width: 250px; /* Wider button */
    margin-left: auto;
    margin-right: auto;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.submit-btn:hover:not(:disabled) {
    background-color: #ffc833; /* Lighter accent on hover */
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    transform: translateY(-1px);
}
.submit-btn:disabled { /* Style when quiz is submitted */
     background-color: #cccccc;
     color: #666666;
     cursor: not-allowed;
     box-shadow: none;
     transform: none;
     opacity: 0.7;
}


.progress-container {
    width: 100%;
    background-color: #e0e0e0;
    border-radius: 10px;
    margin: 20px 0;
    height: 10px; /* Slightly thicker */
    overflow: hidden; /* Ensure bar stays within bounds */
}

.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--secondary));
    border-radius: 10px;
    width: 0%; /* Start at 0 */
    transition: width 0.5s ease-in-out;
}

.edit-btn, .export-btn {
    position: absolute;
    top: 15px;
    background-color: rgba(255, 255, 255, 0.2); /* Semi-transparent */
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.5); /* Light border */
    width: 35px; /* Slightly larger */
    height: 35px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px; /* Larger icon */
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: background-color 0.3s, transform 0.2s;
    z-index: 10; /* Ensure they are above other header content */
}
.edit-btn:hover, .export-btn:hover {
    background-color: rgba(255, 255, 255, 0.4);
    transform: scale(1.1);
}

.edit-btn {
    right: 15px;
}
.export-btn {
    right: 60px; /* Spaced from edit */
}

.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.6); /* Darker overlay */
    z-index: 1000;
    overflow-y: auto;
    padding-top: 30px; /* Add padding */
    padding-bottom: 30px;
}

.modal-content {
    background-color: white;
    margin: 30px auto; /* Adjusted margin */
    padding: 25px;
    border-radius: 10px;
    width: 90%;
    max-width: 800px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    position: relative; /* For close button positioning */
}

.close-modal {
    position: absolute; /* Position relative to modal-content */
    top: 10px;
    right: 15px;
    font-size: 28px; /* Larger close icon */
    font-weight: bold;
    color: #aaa;
    cursor: pointer;
    line-height: 1;
    z-index: 1001; /* Above modal content */
}
.close-modal:hover {
    color: #333;
}

.edit-form {
    margin-top: 20px;
}

.edit-form label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
    color: var(--primary);
    font-size: 0.9rem;
}

.edit-form input[type="text"],
.edit-form input[type="url"],
.edit-form textarea,
.edit-form select {
    width: 100%; /* Use 100% and box-sizing */
    padding: 10px; /* Increased padding */
    margin-bottom: 15px;
    border: 1px solid #ccc; /* Slightly darker border */
    border-radius: 5px;
    font-size: 0.9rem; /* Consistent font size */
    box-sizing: border-box; /* Include padding in width calculation */
}
.edit-form textarea {
    resize: vertical; /* Allow vertical resize */
    min-height: 60px; /* Minimum height */
}

.edit-form button, button.remove-item-btn, button.add-item-btn { /* Style all buttons in form */
    background-color: var(--primary);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    margin-right: 10px;
    margin-top: 5px; /* Add some top margin */
    font-size: 0.9rem;
    transition: background-color 0.3s;
}
.edit-form button:hover, button.remove-item-btn:hover, button.add-item-btn:hover {
    background-color: #4a6cdc;
}

button.remove-item-btn {
    background-color: var(--danger);
    margin-left: 10px; /* Space it out */
    font-weight: bold;
    line-height: 1; /* Adjust line height for '×' */
    padding: 6px 10px; /* Fine-tune padding */
}
button.remove-item-btn:hover {
    background-color: #e66a6a;
}

button.add-item-btn {
     background-color: var(--success);
     display: block; /* Make it block level */
     margin-top: 15px; /* Space above add button */
     margin-left: 0; /* Align left */
     margin-right: 0;
     width: fit-content; /* Size to content */
}
button.add-item-btn:hover {
     background-color: #63c899;
}


.edit-section {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #eee; /* Separator line */
}

.edit-item-group { /* Grouping for each editable item (slide, challenge, question, learn item) */
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    background-color: #fdfdff;
    position: relative; /* For remove button positioning */
}
.edit-item-group .remove-item-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 1.2rem; /* Make '×' bigger */
}

.edit-item-group label {
    font-weight: normal; /* Normal weight for sub-labels */
    color: #555;
    font-size: 0.85rem; /* Smaller sub-labels */
}

.edit-item-group input[type="text"],
.edit-item-group input[type="url"],
.edit-item-group textarea,
.edit-item-group select {
    margin-bottom: 10px; /* Reduced margin inside groups */
}

.color-picker {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
    align-items: center; /* Align items vertically */
}

.color-option {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid #ddd;
    transition: transform 0.2s, border-color 0.2s;
}

.color-option.selected {
    border: 3px solid #000; /* Thicker border */
    transform: scale(1.1);
}
input[type="color"] { /* Style the native color picker */
     width: 35px;
     height: 35px;
     border: none;
     padding: 0;
     border-radius: 50%;
     overflow: hidden;
     cursor: pointer;
     vertical-align: middle; /* Align with options */
}


.font-selector {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.font-option {
    padding: 5px 12px; /* More padding */
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s, color 0.3s;
}

.font-option.selected {
    background-color: var(--primary);
    color: white;
    border-color: var(--primary);
}

.size-selector {
    display: flex;
    gap: 10px;
    align-items: center;
    margin-bottom: 15px;
}

.size-option {
    padding: 5px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s, color 0.3s;
}

.size-option.selected {
    background-color: var(--primary);
    color: white;
    border-color: var(--primary);
}

/* Style for incorrect answer inputs in modal */
.incorrect-answer-label {
    font-size: 0.85rem;
    color: #777;
    margin-top: 8px;
    font-weight: normal; /* Override bold label */
}

@media (min-width: 768px) {
    .project-header {
        flex-direction: row;
        text-align: left;
        align-items: center;
        padding: 25px; /* More padding on desktop */
        gap: 25px; /* More gap */
    }

    .project-header img {
        width: 120px; /* Larger image */
    }

    .project-title {
        font-size: 2rem; /* Larger title */
    }
    .project-subtitle {
        font-size: 1rem;
    }

    .tab {
        padding: 10px 20px;
        font-size: 1rem;
    }

    .step {
        align-items: center;
    }

    .step-number {
        width: 35px; /* Larger number circle */
        height: 35px;
        font-size: 1rem;
    }

    /* Optional: Quiz options side-by-side on larger screens */
    /* .quiz-options {
        flex-direction: row;
        flex-wrap: wrap;
    }
    .quiz-option {
        flex-basis: calc(50% - 10px);
        margin-bottom: 10px;
    } */

}

@media (max-width: 600px) {
    .container {
        padding: 10px;
    }
    .project-header {
        padding: 15px;
    }
    .tab-content {
        padding: 15px;
    }
    .edit-btn {
        right: 10px;
        top: 10px;
    }
    .export-btn {
        right: 55px;
        top: 10px;
    }
    h2 { font-size: 1.2rem; }
    .project-title { font-size: 1.4rem; }
    .project-subtitle { font-size: 0.9rem; }
}

/* Utility class to hide elements visually but keep for screen readers */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

</style>
</head>
<body>
<div class="container">
    <div class="project-header">
        <button class="edit-btn" onclick="openEditModal()" aria-label="Edit Content">✏️</button>
        <button class="export-btn" onclick="exportHTML()" aria-label="Export HTML">⬇️</button>
        <img src="https://www.elecfreaks.com/wp-content/uploads/2022/12/2-1.png" alt="Beating Heart Project" id="projectImage">
        <div class="project-title-container">
            <h1 class="project-title" id="projectTitle">Beating Heart Project</h1>
            <p class="project-subtitle" id="projectSubtitle">Make your Micro:bit display a beating heart animation!</p>
        </div>
    </div>

    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <div class="tabs">
        <div class="tab active" onclick="openTab('overview', this)">Overview</div>
        <div class="tab" onclick="openTab('video', this)">Video Lesson</div>
        <div class="tab" onclick="openTab('slides', this)">Step-by-Step</div>
        <div class="tab" onclick="openTab('challenges', this)">Challenges</div>
        <div class="tab" onclick="openTab('quiz', this)">Quiz</div>
    </div>

    <div id="overview" class="tab-content active">
        <h2>About This Project</h2>
        <p id="overviewText">In this project, you'll learn how to create a beating heart animation on your Micro:bit's LED display. This is a great first project to understand how the Micro:bit works!</p>

        <h3>What You'll Learn</h3>
        <div id="learnContainer">
             <p>Loading learning objectives...</p>
        </div>
    </div>

    <div id="video" class="tab-content">
        <h2>Video Lesson</h2>
        <p id="videoIntroText">Watch this video to learn how to create the beating heart animation:</p>

        <h3 id="videoTitle">Programming the Beating Heart</h3>
        <div class="video-container">
            <iframe src="https://www.youtube.com/embed/2yzT7_QGLLc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen id="mainVideo" title="Programming the Beating Heart Video"></iframe>
        </div>

        <h3>Key Points from the Video</h3>
        <ul id="videoKeyPoints" style="font-size: 0.9rem; padding-left: 20px; list-style: disc;">
             <li>Loading key points...</li>
        </ul>
    </div>

    <div id="slides" class="tab-content">
        <h2>Step-by-Step Guide</h2>
        <div class="slideshow" id="slideshowContainer">
             <p>Loading slides...</p>
        </div>
        <div class="slide-nav">
            <button onclick="prevSlide()">Previous</button>
            <button onclick="nextSlide()">Next</button>
        </div>
    </div>

    <div id="challenges" class="tab-content">
        <h2>Project Challenges</h2>
        <p>Try these challenges to extend your learning:</p>
        <div id="challengesContainer">
             <p>Loading challenges...</p>
        </div>
    </div>

    <div id="quiz" class="tab-content">
        <h2>Project Quiz</h2>
        <p>Test what you've learned about the Beating Heart project!</p>
        <div id="quizContainer">
             <p>Loading quiz...</p>
        </div>
        <!-- Final result area will be added by script if needed -->
        <button class="submit-btn" id="submitQuizBtn" onclick="submitQuiz()">Submit Quiz</button>
    </div>
</div>

<!-- Edit Modal -->
<div id="editModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeEditModal()" title="Close Editor">×</span>
        <h2>Edit Content</h2>
        <div class="edit-form">
            <label for="editSection">Select Section to Edit:</label>
            <select id="editSection" onchange="showEditSection()">
                <option value="title">Project Title & Image</option>
                <option value="overview">Overview Text</option>
                <option value="learn">What You'll Learn</option>
                <option value="video">Video Lesson</option>
                <option value="slides">Step-by-Step Slides</option>
                <option value="challenges">Challenges</option>
                <option value="quiz">Quiz Questions</option>
                <option value="style">Style & Colors</option>
            </select>

            <!-- === Title Edit === -->
            <div id="titleEdit" class="edit-section">
                <label for="editProjectTitle">Project Title:</label>
                <input type="text" id="editProjectTitle">

                <label for="editProjectSubtitle">Subtitle:</label>
                <input type="text" id="editProjectSubtitle">

                <label for="projectImageUrl">Project Image URL:</label>
                <input type="url" id="projectImageUrl">
                <p style="font-size: 0.8rem; color: #666;">Recommended size: ~120px wide. Use a direct image link (e.g., ends in .png, .jpg).</p>
            </div>

            <!-- === Overview Edit === -->
            <div id="overviewEdit" class="edit-section" style="display:none;">
                <label for="editOverviewText">Overview Text:</label>
                <textarea id="editOverviewText" rows="5"></textarea>
            </div>

            <!-- === Learn Edit === -->
            <div id="learnEdit" class="edit-section" style="display:none;">
                <h3>"What You'll Learn" Items</h3>
                <div id="learnEditContainer">
                    <!-- Learn items edit fields will be added here dynamically -->
                </div>
                <button type="button" class="add-item-btn" onclick="addLearnEditField()">Add Learning Item</button>
            </div>

            <!-- === Video Edit === -->
            <div id="videoEdit" class="edit-section" style="display:none;">
                 <label for="editVideoIntroText">Introduction Text:</label>
                 <input type="text" id="editVideoIntroText">

                 <label for="editVideoTitle">Video Section Title:</label>
                 <input type="text" id="editVideoTitle">

                 <label for="editMainVideoUrl">Video Embed URL:</label>
                 <input type="url" id="editMainVideoUrl">
                 <p style="font-size: 0.8rem; color: #666;">Use the 'embed' URL from YouTube/Vimeo etc.</p>


                 <label for="editVideoKeyPoints">Key Points (one per line):</label>
                 <textarea id="editVideoKeyPoints" rows="5"></textarea>
            </div>

            <!-- === Slides Edit === -->
            <div id="slidesEdit" class="edit-section" style="display:none;">
                <h3>Step-by-Step Slides</h3>
                <p>Add slides with multimedia content (image, video, or presentation URL). Max 10 slides.</p>
                <div id="slidesEditContainer">
                    <!-- Slides edit fields will be added here dynamically -->
                </div>
                <button type="button" class="add-item-btn" onclick="addSlideEditField()">Add Slide</button>
            </div>

            <!-- === Challenges Edit === -->
            <div id="challengesEdit" class="edit-section" style="display:none;">
                <h3>Project Challenges</h3>
                <p>Add challenges for users. Max 10 challenges.</p>
                <div id="challengesEditContainer">
                    <!-- Challenges edit fields will be added here dynamically -->
                </div>
                <button type="button" class="add-item-btn" onclick="addChallengeEditField()">Add Challenge</button>
            </div>

            <!-- === Quiz Edit === -->
            <div id="quizEdit" class="edit-section" style="display:none;">
                <h3>Quiz Questions</h3>
                <p>Add questions. Mark one answer as correct. Provide 2-3 incorrect options.</p>
                 <div id="quizEditContainer">
                     <!-- Quiz questions edit fields will be added here dynamically -->
                 </div>
                 <button type="button" class="add-item-btn" onclick="addQuizEditField()">Add Question</button>
            </div>

            <!-- === Style Edit === -->
            <div id="styleEdit" class="edit-section" style="display:none;">
                 <h4>Theme Colors</h4>
                 <label>Primary Color:</label>
                 <div class="color-picker">
                     <div class="color-option" style="background-color: #5E81F4;" onclick="selectColor('primary', '#5E81F4')"></div>
                     <div class="color-option" style="background-color: #FF7AC6;" onclick="selectColor('primary', '#FF7AC6')"></div>
                     <div class="color-option" style="background-color: #7CE7AC;" onclick="selectColor('primary', '#7CE7AC')"></div>
                     <div class="color-option" style="background-color: #FFB800;" onclick="selectColor('primary', '#FFB800')"></div>
                     <div class="color-option" style="background-color: #9B51E0;" onclick="selectColor('primary', '#9B51E0')"></div>
                     <input type="color" id="primaryColorPicker" oninput="customColorSelected('primary', this.value)">
                 </div>

                 <label>Secondary Color:</label>
                 <div class="color-picker">
                     <div class="color-option" style="background-color: #5E81F4;" onclick="selectColor('secondary', '#5E81F4')"></div>
                     <div class="color-option" style="background-color: #FF7AC6;" onclick="selectColor('secondary', '#FF7AC6')"></div>
                     <div class="color-option" style="background-color: #7CE7AC;" onclick="selectColor('secondary', '#7CE7AC')"></div>
                     <div class="color-option" style="background-color: #FFB800;" onclick="selectColor('secondary', '#FFB800')"></div>
                     <div class="color-option" style="background-color: #9B51E0;" onclick="selectColor('secondary', '#9B51E0')"></div>
                     <input type="color" id="secondaryColorPicker" oninput="customColorSelected('secondary', this.value)">
                 </div>

                 <label>Accent Color:</label>
                 <div class="color-picker">
                     <div class="color-option" style="background-color: #5E81F4;" onclick="selectColor('accent', '#5E81F4')"></div>
                     <div class="color-option" style="background-color: #FF7AC6;" onclick="selectColor('accent', '#FF7AC6')"></div>
                     <div class="color-option" style="background-color: #7CE7AC;" onclick="selectColor('accent', '#7CE7AC')"></div>
                     <div class="color-option" style="background-color: #FFB800;" onclick="selectColor('accent', '#FFB800')"></div>
                     <div class="color-option" style="background-color: #9B51E0;" onclick="selectColor('accent', '#9B51E0')"></div>
                     <input type="color" id="accentColorPicker" oninput="customColorSelected('accent', this.value)">
                 </div>

                 <h4>Typography</h4>
                 <label>Font Family:</label>
                 <div class="font-selector">
                     <div class="font-option" onclick="selectFont('Comic Sans MS, Segoe UI, sans-serif')" style="font-family: 'Comic Sans MS', sans-serif;">Comic Sans</div>
                     <div class="font-option" onclick="selectFont('Arial, Helvetica, sans-serif')" style="font-family: Arial, sans-serif;">Arial</div>
                     <div class="font-option" onclick="selectFont('Georgia, Times New Roman, serif')" style="font-family: Georgia, serif;">Georgia</div>
                     <div class="font-option" onclick="selectFont('Courier New, monospace')" style="font-family: 'Courier New', monospace;">Courier New</div>
                     <div class="font-option" onclick="selectFont('Verdana, Geneva, sans-serif')" style="font-family: Verdana, sans-serif;">Verdana</div>
                     <div class="font-option" onclick="selectFont('Tahoma, sans-serif')" style="font-family: Tahoma, sans-serif;">Tahoma</div>
                 </div>

                 <label>Base Text Size:</label>
                 <div class="size-selector">
                     <div class="size-option" onclick="selectSize('small')">Small</div>
                     <div class="size-option" onclick="selectSize('medium')">Medium</div>
                     <div class="size-option" onclick="selectSize('large')">Large</div>
                 </div>
            </div>

            <hr style="margin: 25px 0;">
            <button type="button" onclick="saveChanges()" style="background-color: var(--success); margin-right: 15px;">Save Changes</button>
            <button type="button" onclick="closeEditModal()" style="background-color: #aaa;">Cancel</button>
        </div>
    </div>
</div>

<script>
    // --- Global Data Storage ---
    let currentSlideIndex = 0;
    let slidesData = [
        { url: "https://view.genially.com/67de49ded67908621a726b03", description: "1. Introduction to the Beating Heart project", type: "iframe" },
        { url: "https://view.genially.com/67de49e4ab31ac746b27c48b", description: "2. Setting up your Micro:bit environment", type: "iframe" },
        { url: "https://clearinghouse.starnetlibraries.org/images/525/microbit-heart.jpg", description: "3. Programming the Beating Heart animation", type: "image" },
    ];
    const MAX_SLIDES = 10;

    let challengesData = [
        { title: "Faster or Slower?", description: "Change the pause times (milliseconds) in the code to speed up or slow down the heartbeat." },
        { title: "Different Animation", description: "Try creating a different simple animation, like a blinking smiley face or a flashing arrow." },
        { title: "Button Control", description: "Modify the code so the animation only plays when Button A is pressed." },
        // { title: "Add Sound", description: "If you have a Micro:bit v2, try adding a simple sound effect that plays with the heart beat using the music blocks." },
    ];
     const MAX_CHALLENGES = 10;

    let learnData = [
        { title: "Hardware Basics", description: "Understand the Micro:bit LED matrix (5x5 grid) and how to connect & flash code." },
        { title: "Core Programming Blocks", description: "Learn the difference between 'on start' (runs once) and 'forever' (loops continuously)." },
        { title: "Animation Technique", description: "Use 'show leds' or 'show icon' combined with 'pause' blocks to create the illusion of movement." },
        { title: "Computational Thinking: Sequencing", description: "Understand that the order of blocks matters for the animation to work correctly." }
    ];
    const MAX_LEARN_ITEMS = 8;

    let quizData = [
         {
             questionText: "What block makes code run repeatedly forever?",
             correctAnswer: "'forever' loop",
             incorrectAnswers: ["'on start' block", "'pause (ms)' block", "'show leds' block"]
         },
         {
             questionText: "How many individual LEDs are on the Micro:bit display?",
             correctAnswer: "25 (a 5x5 grid)",
             incorrectAnswers: ["10", "5", "100"]
         },
         {
             questionText: "To create an animation, you typically show something, then...",
             correctAnswer: "Pause, then show something different",
             incorrectAnswers: ["Immediately show something different", "Stop the program", "Shake the Micro:bit"]
         },
         {
             questionText: "What does the 'pause (ms)' block measure time in?",
             correctAnswer: "Milliseconds (1/1000th of a second)",
             incorrectAnswers: ["Seconds", "Minutes", "Microseconds"]
         }
     ];
     const MAX_QUIZ_QUESTIONS = 10;
     const MAX_INCORRECT_ANSWERS = 3; // Max incorrect options per question in editor

    // --- Project Data Store (for non-array content) ---
    let projectData = {
         title: "Beating Heart Project",
         subtitle: "Make your Micro:bit display a beating heart animation!",
         imageUrl: "https://www.elecfreaks.com/wp-content/uploads/2022/12/2-1.png",
         overviewText: "In this project, you'll learn how to create a beating heart animation on your Micro:bit's LED display. This is a great first project to understand how the Micro:bit works!",
         videoIntroText: "Watch this video to learn how to create the beating heart animation:",
         videoTitle: "Programming the Beating Heart",
         videoUrl: "https://www.youtube.com/embed/2yzT7_QGLLc",
         videoKeyPoints: [
            "The LED matrix has 25 lights (5 rows x 5 columns)",
            "'on start' runs once when the Micro:bit turns on",
            "'forever' keeps repeating the code inside it",
            "We use 'show icon'/'show leds' and 'pause' blocks to create animation"
         ],
         style: { // Store style preferences
            primaryColor: '#5E81F4',
            secondaryColor: '#FF7AC6',
            accentColor: '#FFB800',
            fontFamily: 'Comic Sans MS, Segoe UI, sans-serif',
            baseSize: 'medium'
         }
    };


    // --- Tab Functionality ---
    function openTab(tabName, element) {
        const tabs = document.querySelectorAll('.tab-content');
        tabs.forEach(tab => tab.classList.remove('active'));

        const tabButtons = document.querySelectorAll('.tab');
        tabButtons.forEach(btn => btn.classList.remove('active'));

        const targetTab = document.getElementById(tabName);
        if (targetTab) targetTab.classList.add('active');

        if (element) {
            element.classList.add('active');
        } else {
            // Fallback if element not passed (e.g., on initial load)
            const currentTabButton = document.querySelector(`.tab[onclick*="openTab('${tabName}'"]`);
            if (currentTabButton) currentTabButton.classList.add('active');
        }

        updateProgressBar(tabName);
    }

    // --- Progress Bar ---
    function updateProgressBar(tab) {
        let progress = 0;
        const tabOrder = ['overview', 'video', 'slides', 'challenges', 'quiz'];
        const tabIndex = tabOrder.indexOf(tab);

        if (tabIndex >= 0) {
            progress = ((tabIndex + 1) / tabOrder.length) * 100;
        }

        const progressBar = document.getElementById('progressBar');
        if(progressBar) progressBar.style.width = progress + '%';
    }

    // --- Slideshow Functionality ---
    function renderSlideshow() {
        const container = document.getElementById('slideshowContainer');
        const nav = document.querySelector('.slide-nav');
        if (!container || !nav) return;

        container.innerHTML = ''; // Clear existing
        const validSlides = slidesData.filter(slide => slide.url && slide.url.trim() !== '');

        if (validSlides.length === 0) {
             container.innerHTML = '<p>No slides have been added yet.</p>';
             nav.style.display = 'none'; // Hide nav if no slides
             return;
        }
        nav.style.display = 'flex'; // Show nav if slides exist

        validSlides.forEach((slide, index) => {
            const slideDiv = document.createElement('div');
            slideDiv.className = 'slide';
            // Note: Active class is added by showSlide

            const slideContentWrapper = document.createElement('div');
            slideContentWrapper.className = 'slide-content-wrapper';

            if (slide.type === 'iframe') {
                let iframeSrc = slide.url;
                slideContentWrapper.innerHTML = `<iframe src="${iframeSrc}" frameborder="0" loading="lazy" allowfullscreen sandbox="allow-scripts allow-same-origin allow-presentation" title="${slide.description || `Slide ${index + 1}`}"></iframe>`;
            } else if (slide.type === 'image') {
                slideContentWrapper.innerHTML = `<img src="${slide.url}" loading="lazy" alt="${slide.description || `Slide ${index + 1}`}">`;
            }

            slideDiv.appendChild(slideContentWrapper);
            if (slide.description) {
                 const descP = document.createElement('p');
                 descP.textContent = slide.description;
                 slideDiv.appendChild(descP);
            }
            container.appendChild(slideDiv);
        });

        currentSlideIndex = 0; // Reset index to the first slide
        showSlide(currentSlideIndex); // Ensure the first slide is displayed correctly
    }

    function showSlide(n) {
        const slides = document.querySelectorAll('#slideshowContainer .slide');
        const validSlidesCount = slides.length; // Only count rendered slides
        if (validSlidesCount === 0) return;

        slides.forEach(slide => slide.classList.remove('active'));

        // Ensure index wraps around correctly
        currentSlideIndex = (n % validSlidesCount + validSlidesCount) % validSlidesCount;

        if (slides[currentSlideIndex]) {
             slides[currentSlideIndex].classList.add('active');
        }
    }

    function nextSlide() {
        showSlide(currentSlideIndex + 1);
    }

    function prevSlide() {
        showSlide(currentSlideIndex - 1);
    }

    // --- "What You'll Learn" Rendering ---
    function renderLearnItems() {
         const container = document.getElementById('learnContainer');
         if (!container) return;
         container.innerHTML = ''; // Clear existing
         const validItems = learnData.filter(item => item.title && item.title.trim() !== '');

         if (validItems.length === 0) {
             container.innerHTML = '<p>Learning objectives will be listed here.</p>';
             return;
         }

         validItems.forEach((item, index) => {
            const learnDiv = document.createElement('div');
            learnDiv.className = 'step'; // Reuse step styling
            learnDiv.innerHTML = `
                <div class="step-number">${index + 1}</div>
                <div class="step-content">
                    <strong></strong>
                    <p></p>
                </div>
            `;
            // Set text content safely
            learnDiv.querySelector('strong').textContent = item.title;
            learnDiv.querySelector('p').textContent = item.description || '';
            container.appendChild(learnDiv);
         });
    }

    // --- Challenges Rendering ---
    function renderChallenges() {
        const container = document.getElementById('challengesContainer');
         if (!container) return;
        container.innerHTML = ''; // Clear existing
        const validChallenges = challengesData.filter(challenge => challenge.title && challenge.title.trim() !== '');

        if (validChallenges.length === 0) {
             container.innerHTML = '<p>No challenges have been added yet.</p>';
             return;
        }

        validChallenges.forEach((challenge, index) => {
            const challengeDiv = document.createElement('div');
            challengeDiv.className = 'step'; // Reuse step styling

            challengeDiv.innerHTML = `
                <div class="step-number">★</div>
                <div class="step-content">
                     <strong></strong>
                     <p></p>
                </div>
            `;
            // Set text content safely
            challengeDiv.querySelector('strong').textContent = challenge.title;
            challengeDiv.querySelector('p').textContent = challenge.description || '';
            container.appendChild(challengeDiv);
        });
    }


    // --- Quiz Rendering & Functionality ---
    function renderQuiz() {
        const container = document.getElementById('quizContainer');
        const submitBtn = document.getElementById('submitQuizBtn');
         if (!container || !submitBtn) return;

        container.innerHTML = ''; // Clear previous quiz
        // Remove any previous final result div
        container.querySelector('.final-quiz-result')?.remove();

        submitBtn.disabled = false; // Re-enable submit button
        submitBtn.style.display = 'none'; // Hide initially

        const validQuestions = quizData.filter(q => q.questionText && q.questionText.trim() && q.correctAnswer && q.correctAnswer.trim());

        if (validQuestions.length === 0) {
            container.innerHTML = '<p>No quiz questions added yet.</p>';
            return; // Keep button hidden
        }

        submitBtn.style.display = 'block'; // Show button if questions exist

        validQuestions.forEach((q, index) => {
            const questionDiv = document.createElement('div');
            questionDiv.className = 'quiz-question';
            questionDiv.setAttribute('data-question-index', index); // Store original index if needed? Or just sequential index? Using sequential for now.

            const questionTextP = document.createElement('p');
            questionTextP.className = 'question-text';
            questionTextP.textContent = `${index + 1}. ${q.questionText}`;
            questionDiv.appendChild(questionTextP);

            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'quiz-options';

            // Combine correct and valid incorrect answers, then shuffle
            let options = [q.correctAnswer, ...q.incorrectAnswers.filter(ans => ans && ans.trim() !== '')];
            shuffleArray(options); // Shuffle options for display

            options.forEach((optionText) => {
                const isCorrect = (optionText === q.correctAnswer);
                const optionEl = document.createElement('div');
                optionEl.className = 'quiz-option';
                optionEl.textContent = optionText;
                optionEl.setAttribute('role', 'button'); // Accessibility
                optionEl.setAttribute('tabindex', '0');   // Accessibility
                optionEl.onclick = () => selectQuizOption(optionEl);
                optionEl.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') selectQuizOption(optionEl); }; // Accessibility
                // Store correctness info for checking on submit
                optionEl.setAttribute('data-is-correct', isCorrect.toString());
                optionsDiv.appendChild(optionEl);
            });

            questionDiv.appendChild(optionsDiv);

            // Add feedback divs (initially hidden and empty)
            const feedbackCorrect = document.createElement('div');
            feedbackCorrect.className = 'quiz-feedback correct';
            feedbackCorrect.style.display = 'none'; // Ensure hidden
            questionDiv.appendChild(feedbackCorrect);

            const feedbackIncorrect = document.createElement('div');
            feedbackIncorrect.className = 'quiz-feedback incorrect';
            feedbackIncorrect.style.display = 'none'; // Ensure hidden
            questionDiv.appendChild(feedbackIncorrect);


            container.appendChild(questionDiv);
        });
    }

    function selectQuizOption(optionElement) {
        const questionDiv = optionElement.closest('.quiz-question');
        // Only allow selection if the quiz hasn't been submitted for this question
        if (!questionDiv || questionDiv.classList.contains('answered')) return;

        const allOptions = questionDiv.querySelectorAll('.quiz-option');
        allOptions.forEach(opt => opt.classList.remove('selected'));

        optionElement.classList.add('selected');
    }

    function submitQuiz() {
        const questions = document.querySelectorAll('#quizContainer .quiz-question');
        let answeredCount = 0;
        let score = 0;
        const totalQuestions = questions.length; // Count actual rendered questions

        if (totalQuestions === 0) return; // No questions to submit

        let firstUnanswered = null;

        questions.forEach((qDiv, index) => {
            const selectedOption = qDiv.querySelector('.quiz-option.selected');
            const feedbackCorrect = qDiv.querySelector('.quiz-feedback.correct');
            const feedbackIncorrect = qDiv.querySelector('.quiz-feedback.incorrect');
            const allOptions = qDiv.querySelectorAll('.quiz-option');

            // Reset feedback display first
             if(feedbackCorrect) feedbackCorrect.style.display = 'none';
             if(feedbackIncorrect) feedbackIncorrect.style.display = 'none';
             qDiv.classList.remove('answered'); // Temporarily remove while checking
             allOptions.forEach(opt => {
                 opt.classList.remove('correct', 'incorrect'); // Clear result styles
                 opt.style.opacity = '1'; // Reset opacity
                 opt.style.cursor = 'pointer'; // Reset cursor
                  opt.onclick = () => selectQuizOption(opt); // Re-enable click (will be disabled below if answered)
                  opt.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') selectQuizOption(opt); };
             });


            if (selectedOption) {
                answeredCount++;
                qDiv.classList.add('answered'); // Mark question as answered FOR DISPLAY

                const isCorrect = selectedOption.getAttribute('data-is-correct') === 'true';

                // Style all options to show the result
                allOptions.forEach(opt => {
                     const optIsCorrect = opt.getAttribute('data-is-correct') === 'true';

                     // Always highlight the correct answer green
                     if (optIsCorrect) {
                         opt.classList.add('correct');
                     }

                     // If this option was the one selected:
                     if (opt.classList.contains('selected')) {
                          // Add 'incorrect' style ONLY if it's the selected one AND it's wrong
                          if (!isCorrect) {
                              opt.classList.add('incorrect');
                          }
                     } else if (!optIsCorrect) {
                         // Dim options that were NOT selected and are NOT the correct answer
                         opt.style.opacity = "0.6";
                     }

                     // Disable further interaction on all options for this question
                     opt.style.cursor = "default";
                     opt.onclick = null;
                     opt.onkeydown = null;
                });


                if (isCorrect) {
                    score++;
                    if(feedbackCorrect) {
                         feedbackCorrect.textContent = 'Correct!'; // Set feedback text
                         feedbackCorrect.style.display = 'block';
                    }
                } else {
                     if(feedbackIncorrect) {
                         const correctOptionElement = qDiv.querySelector('.quiz-option.correct');
                         const correctAnswerText = correctOptionElement ? correctOptionElement.textContent : "the highlighted option";
                         feedbackIncorrect.textContent = `Not quite. The correct answer was: "${correctAnswerText}".`; // Provide more specific feedback
                         feedbackIncorrect.style.display = 'block';
                     }
                }
            } else if (!firstUnanswered) {
                 // Store the first question that wasn't answered
                 firstUnanswered = qDiv;
            }
        });

        // Check if all questions were answered
        if (answeredCount < totalQuestions) {
            alert(`Please answer all ${totalQuestions} questions before submitting!`);
            // Optionally scroll to the first unanswered question
            if (firstUnanswered) {
                 firstUnanswered.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 // Maybe add a temporary highlight to the unanswered question?
                 firstUnanswered.style.outline = '2px solid red';
                 setTimeout(() => { firstUnanswered.style.outline = 'none'; }, 2000);
            }
             // IMPORTANT: Reset styles if not all answered, so user can try again
             questions.forEach(qDiv => {
                  qDiv.classList.remove('answered');
                  qDiv.querySelectorAll('.quiz-feedback').forEach(fb => fb.style.display = 'none');
                  qDiv.querySelectorAll('.quiz-option').forEach(opt => {
                       opt.classList.remove('selected', 'correct', 'incorrect');
                       opt.style.opacity = '1';
                       opt.style.cursor = 'pointer';
                       opt.onclick = () => selectQuizOption(opt); // Ensure clicks are re-enabled
                       opt.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') selectQuizOption(opt); };
                  });
             });
            return;
        }

        // All answered, disable button and show result
        const submitBtn = document.getElementById('submitQuizBtn');
        if(submitBtn) submitBtn.disabled = true;

        // Add or update final result div
        const resultContainer = document.getElementById('quizContainer');
        let resultDiv = resultContainer.querySelector('.final-quiz-result');
         if (!resultDiv) {
             resultDiv = document.createElement('div');
             resultDiv.className = 'final-quiz-result'; // Assign class for styling
             resultContainer.appendChild(resultDiv); // Append at the end
         }

        resultDiv.textContent = `Quiz Complete! You scored ${score} out of ${totalQuestions}!`;
        resultDiv.className = 'final-quiz-result ' + ((score / totalQuestions) >= 0.7 ? 'success' : 'fail'); // Add result class
        resultDiv.style.display = 'block';

        // Scroll to result
        resultDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // --- Edit Modal Functionality ---
    function openEditModal() {
        const modal = document.getElementById('editModal');
        if (!modal) return;

        // Load current data into edit form
        document.getElementById('editProjectTitle').value = projectData.title;
        document.getElementById('editProjectSubtitle').value = projectData.subtitle;
        document.getElementById('projectImageUrl').value = projectData.imageUrl;
        document.getElementById('editOverviewText').value = projectData.overviewText;

        // Load video tab data
        document.getElementById('editVideoIntroText').value = projectData.videoIntroText;
        document.getElementById('editVideoTitle').value = projectData.videoTitle;
        document.getElementById('editMainVideoUrl').value = projectData.videoUrl;
        document.getElementById('editVideoKeyPoints').value = projectData.videoKeyPoints.join('\n');

        // Load dynamic sections
        loadLearnEditFields();
        loadSlidesEditFields();
        loadChallengesEditFields();
        loadQuizEditFields();

        // Load Style selections
        loadStyleSelections();

        modal.style.display = 'block';
        // Ensure the correct initial edit section is shown based on dropdown
        showEditSection();
    }

    function closeEditModal() {
         const modal = document.getElementById('editModal');
         if(modal) modal.style.display = 'none';
    }

    function showEditSection() {
        const sections = document.querySelectorAll('.edit-section');
        sections.forEach(section => section.style.display = 'none');

        const selectElement = document.getElementById('editSection');
        if (!selectElement) return;

        const selectedSectionId = selectElement.value + 'Edit';
        const selectedSection = document.getElementById(selectedSectionId);
         if(selectedSection) {
             selectedSection.style.display = 'block';
         }
    }

    // --- Editor Field Loaders ---

    function createEditItemGroup(index, type, contentGenerator, removeFunction) {
         const itemGroup = document.createElement('div');
         itemGroup.className = 'edit-item-group';
         itemGroup.setAttribute(`data-${type}-index`, index); // Keep index if needed internally
         itemGroup.innerHTML = contentGenerator(index); // Generate specific inputs

         const removeBtn = document.createElement('button');
         removeBtn.type = 'button';
         removeBtn.className = 'remove-item-btn';
         removeBtn.innerHTML = '×'; // Use HTML entity for '×'
         removeBtn.title = `Remove ${type.charAt(0).toUpperCase() + type.slice(1)} ${index + 1}`;
         // Pass the *specific group element* to the remove function
         removeBtn.onclick = () => removeFunction(itemGroup);
         itemGroup.appendChild(removeBtn);

         return itemGroup;
    }


    function loadLearnEditFields() {
        const container = document.getElementById('learnEditContainer');
        if (!container) return;
        container.innerHTML = ''; // Clear existing
        learnData.forEach((item, index) => {
             const content = (i) => `
                 <label for="learn-title-${i}">Item ${i + 1} Title:</label>
                 <input type="text" id="learn-title-${i}" class="learn-title" value="${item.title || ''}">
                 <label for="learn-desc-${i}">Item ${i + 1} Description:</label>
                 <textarea id="learn-desc-${i}" class="learn-desc" rows="2">${item.description || ''}</textarea>
             `;
             // Pass the remove *handler* function, not calling it yet
             container.appendChild(createEditItemGroup(index, 'learn', content, handleRemoveLearnItem));
        });
    }

    function loadSlidesEditFields() {
        const container = document.getElementById('slidesEditContainer');
         if (!container) return;
        container.innerHTML = '';
        slidesData.forEach((slide, index) => {
             const content = (i) => `
                <label for="slide-url-${i}">Slide ${i + 1} URL (Image or Embed Link):</label>
                <input type="url" id="slide-url-${i}" class="slide-url" value="${slide.url || ''}">
                <label for="slide-desc-${i}">Slide ${i + 1} Description (Optional):</label>
                <input type="text" id="slide-desc-${i}" class="slide-desc" value="${slide.description || ''}">
                <label for="slide-type-${i}">Slide ${i + 1} Type:</label>
                <select id="slide-type-${i}" class="slide-type">
                    <option value="iframe" ${slide.type === 'iframe' ? 'selected' : ''}>Presentation/Video Embed</option>
                    <option value="image" ${slide.type === 'image' ? 'selected' : ''}>Image</option>
                </select>
             `;
             container.appendChild(createEditItemGroup(index, 'slide', content, handleRemoveSlideItem));
        });
    }

     function loadChallengesEditFields() {
        const container = document.getElementById('challengesEditContainer');
         if (!container) return;
        container.innerHTML = '';
        challengesData.forEach((challenge, index) => {
            const content = (i) => `
                 <label for="challenge-title-${i}">Challenge ${i + 1} Title:</label>
                 <input type="text" id="challenge-title-${i}" class="challenge-title" value="${challenge.title || ''}">
                 <label for="challenge-desc-${i}">Challenge ${i + 1} Description (Optional):</label>
                 <textarea id="challenge-desc-${i}" class="challenge-desc" rows="2">${challenge.description || ''}</textarea>
             `;
             container.appendChild(createEditItemGroup(index, 'challenge', content, handleRemoveChallengeItem));
        });
    }

    function loadQuizEditFields() {
         const container = document.getElementById('quizEditContainer');
         if (!container) return;
         container.innerHTML = '';
         quizData.forEach((q, index) => {
              let incorrectInputsHTML = '';
              for (let i = 0; i < MAX_INCORRECT_ANSWERS; i++) {
                   const val = q.incorrectAnswers[i] || '';
                   // Add unique IDs for labels/inputs
                   incorrectInputsHTML += `
                        <label for="quiz-incorrect-${index}-${i}" class="incorrect-answer-label">Incorrect Answer ${i + 1}:</label>
                        <input type="text" id="quiz-incorrect-${index}-${i}" class="quiz-incorrect" value="${val}">
                   `;
              }

              const content = (i) => `
                 <label for="quiz-question-${i}">Question ${i + 1}:</label>
                 <textarea id="quiz-question-${i}" class="quiz-question" rows="2">${q.questionText || ''}</textarea>
                 <label for="quiz-correct-${i}">Correct Answer:</label>
                 <input type="text" id="quiz-correct-${i}" class="quiz-correct" value="${q.correctAnswer || ''}">
                 ${incorrectInputsHTML}
              `;
              container.appendChild(createEditItemGroup(index, 'quiz', content, handleRemoveQuizItem));
         });
    }

    // --- Editor Add/Remove Handlers ---
    // These functions find the element in the DOM and update the corresponding data array

    function findIndexAndRemove(element, dataArray, reloadFunction) {
        const container = element.parentNode;
        const items = Array.from(container.children).filter(child => child.classList.contains('edit-item-group'));
        const index = items.indexOf(element);

        if (index > -1) {
             if (dataArray.length <= 1) {
                  // Optional: Clear the fields instead of removing the last item?
                  // For now, just prevent removal if it's the only one.
                  alert("Cannot remove the last item. Edit it or add another first.");
                  return; // Or clear dataArray[0] fields
             }
             dataArray.splice(index, 1);
             reloadFunction(); // Reload the fields to reflect the change and update indices
        } else {
             console.error("Could not find item index to remove.");
        }
    }

    function handleRemoveLearnItem(elementToRemove) {
        findIndexAndRemove(elementToRemove, learnData, loadLearnEditFields);
    }
    function handleRemoveSlideItem(elementToRemove) {
        findIndexAndRemove(elementToRemove, slidesData, loadSlidesEditFields);
    }
     function handleRemoveChallengeItem(elementToRemove) {
        findIndexAndRemove(elementToRemove, challengesData, loadChallengesEditFields);
    }
     function handleRemoveQuizItem(elementToRemove) {
        findIndexAndRemove(elementToRemove, quizData, loadQuizEditFields);
    }


    // --- Editor Add Button Functions ---

    function addLearnEditField() {
        if (learnData.length >= MAX_LEARN_ITEMS) {
            alert(`Maximum of ${MAX_LEARN_ITEMS} learning items allowed.`);
            return;
        }
        learnData.push({ title: "", description: "" });
        loadLearnEditFields(); // Reload to add the new empty field
        // Scroll to the new item
        const container = document.getElementById('learnEditContainer');
        container?.lastElementChild?.scrollIntoView({ behavior: 'smooth', block: 'nearest'});
    }

     function addSlideEditField() {
        if (slidesData.length >= MAX_SLIDES) {
            alert(`Maximum of ${MAX_SLIDES} slides allowed.`);
            return;
        }
        slidesData.push({ url: "", description: "", type: "iframe" });
        loadSlidesEditFields();
        document.getElementById('slidesEditContainer')?.lastElementChild?.scrollIntoView({ behavior: 'smooth', block: 'nearest'});
    }

    function addChallengeEditField() {
        if (challengesData.length >= MAX_CHALLENGES) {
            alert(`Maximum of ${MAX_CHALLENGES} challenges allowed.`);
            return;
        }
        challengesData.push({ title: "", description: "" });
        loadChallengesEditFields();
        document.getElementById('challengesEditContainer')?.lastElementChild?.scrollIntoView({ behavior: 'smooth', block: 'nearest'});
    }

     function addQuizEditField() {
        if (quizData.length >= MAX_QUIZ_QUESTIONS) {
            alert(`Maximum of ${MAX_QUIZ_QUESTIONS} questions allowed.`);
            return;
        }
        // Add empty structure matching quizData items
        quizData.push({ questionText: "", correctAnswer: "", incorrectAnswers: Array(MAX_INCORRECT_ANSWERS).fill("") });
        loadQuizEditFields();
        document.getElementById('quizEditContainer')?.lastElementChild?.scrollIntoView({ behavior: 'smooth', block: 'nearest'});
    }

    // --- Style Editor Functions ---
     function selectColor(type, color) {
        document.documentElement.style.setProperty(`--${type}`, color);

        // Update color picker selection state visually
        const pickerContainer = document.querySelector(`#${type}ColorPicker`)?.closest('.color-picker');
        if (!pickerContainer) return;

        const colorOptions = pickerContainer.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
            const optionColor = option.style.backgroundColor;
            // Use helper for comparison
            option.classList.toggle('selected', areColorsEqual(optionColor, color));
        });
         // Update the input type=color value as well
         const colorInput = document.getElementById(`${type}ColorPicker`);
         if(colorInput) colorInput.value = color;

         // Store the preference
         projectData.style[type + 'Color'] = color;
    }

    function customColorSelected(type, color) {
        selectColor(type, color); // Directly update the CSS variable and store preference
        // Deselect preset options visually when custom color is chosen/input
        const pickerContainer = document.querySelector(`#${type}ColorPicker`)?.closest('.color-picker');
        if (!pickerContainer) return;
         const colorOptions = pickerContainer.querySelectorAll('.color-option');
         colorOptions.forEach(option => option.classList.remove('selected'));
    }

    function selectFont(font) {
        document.body.style.fontFamily = font;
        // Update font option selections
        const fontOptions = document.querySelectorAll('.font-option');
        fontOptions.forEach(option => {
             const optionFont = option.getAttribute('onclick').match(/selectFont\('(.*?)'\)/)?.[1];
             option.classList.toggle('selected', optionFont === font);
        });
        projectData.style.fontFamily = font; // Store preference
    }

    function selectSize(size) {
         let baseFontSize;
         if (size === 'small') baseFontSize = '14px';
         else if (size === 'medium') baseFontSize = '16px';
         else if (size === 'large') baseFontSize = '18px';
         else baseFontSize = '16px'; // Default

         document.documentElement.style.fontSize = baseFontSize; // Apply to root for better scaling

         // Update size option selections
         const sizeOptions = document.querySelectorAll('.size-option');
         sizeOptions.forEach(option => {
             option.classList.toggle('selected', option.textContent.toLowerCase() === size);
         });
         projectData.style.baseSize = size; // Store preference
    }

     function loadStyleSelections() {
        // Set initial colors based on projectData or defaults from CSS variables
        selectColor('primary', projectData.style.primaryColor || getComputedStyle(document.documentElement).getPropertyValue('--primary').trim());
        selectColor('secondary', projectData.style.secondaryColor || getComputedStyle(document.documentElement).getPropertyValue('--secondary').trim());
        selectColor('accent', projectData.style.accentColor || getComputedStyle(document.documentElement).getPropertyValue('--accent').trim());

        // Set initial font
        selectFont(projectData.style.fontFamily || getComputedStyle(document.body).fontFamily);

        // Set initial size
        selectSize(projectData.style.baseSize || 'medium'); // Assume medium default
     }

    // --- Save Changes ---
    function saveChanges() {
        // Save title changes
        projectData.title = document.getElementById('editProjectTitle')?.value.trim() || projectData.title;
        projectData.subtitle = document.getElementById('editProjectSubtitle')?.value.trim() || projectData.subtitle;
        projectData.imageUrl = document.getElementById('projectImageUrl')?.value.trim() || projectData.imageUrl;

        // Save overview text
        projectData.overviewText = document.getElementById('editOverviewText')?.value.trim() || projectData.overviewText;

        // Save "What You'll Learn" items
        const newLearnData = [];
        const learnItems = document.querySelectorAll('#learnEditContainer .edit-item-group');
        learnItems.forEach(item => {
            const titleInput = item.querySelector('.learn-title');
            const descInput = item.querySelector('.learn-desc');
            const title = titleInput?.value.trim();
            // Only add if title is present
            if (title) {
                newLearnData.push({
                    title: title,
                    description: descInput?.value.trim() || ""
                });
            }
        });
        learnData = newLearnData; // Replace the old array


        // Save video tab data
        projectData.videoIntroText = document.getElementById('editVideoIntroText')?.value.trim() || projectData.videoIntroText;
        projectData.videoTitle = document.getElementById('editVideoTitle')?.value.trim() || projectData.videoTitle;
        projectData.videoUrl = document.getElementById('editMainVideoUrl')?.value.trim() || projectData.videoUrl;
        projectData.videoKeyPoints = document.getElementById('editVideoKeyPoints')?.value.split('\n').map(s => s.trim()).filter(s => s !== '') || [];


        // Save slides data from edit form
        const newSlidesData = [];
        const slideItems = document.querySelectorAll('#slidesEditContainer .edit-item-group');
        slideItems.forEach(item => {
            const urlInput = item.querySelector('.slide-url');
            const descInput = item.querySelector('.slide-desc');
            const typeSelect = item.querySelector('.slide-type');
            const url = urlInput?.value.trim();
            // Only add if URL is present
            if (url) {
                newSlidesData.push({
                    url: url,
                    description: descInput?.value.trim() || "",
                    type: typeSelect?.value || "iframe"
                });
            }
        });
         slidesData = newSlidesData;

        // Save challenges data from edit form
        const newChallengesData = [];
        const challengeItems = document.querySelectorAll('#challengesEditContainer .edit-item-group');
        challengeItems.forEach(item => {
             const titleInput = item.querySelector('.challenge-title');
             const descInput = item.querySelector('.challenge-desc');
             const title = titleInput?.value.trim();
             // Only add if title is present
             if(title) {
                  newChallengesData.push({
                      title: title,
                      description: descInput?.value.trim() || ""
                  });
             }
        });
        challengesData = newChallengesData;

        // Save Quiz Data
         const newQuizData = [];
         const quizItems = document.querySelectorAll('#quizEditContainer .edit-item-group');
         quizItems.forEach(item => {
              const questionInput = item.querySelector('.quiz-question');
              const correctInput = item.querySelector('.quiz-correct');
              const incorrectInputs = item.querySelectorAll('.quiz-incorrect'); // NodeList

              const questionText = questionInput?.value.trim();
              const correctAnswer = correctInput?.value.trim();

              // Only add if question and correct answer are present
              if (questionText && correctAnswer) {
                   let incorrectAnswers = [];
                   incorrectInputs.forEach(input => {
                        const incorrectVal = input?.value.trim();
                        if (incorrectVal !== '') {
                             incorrectAnswers.push(incorrectVal);
                        }
                   });
                   // Ensure we have at least one incorrect answer for a valid quiz question? Maybe not strict.
                   newQuizData.push({
                        questionText: questionText,
                        correctAnswer: correctAnswer,
                        incorrectAnswers: incorrectAnswers
                   });
              }
         });
         quizData = newQuizData;

         // Styles are saved directly via selectColor/Font/Size functions storing in projectData.style

        // Update the entire page display with new data
        updatePageContent();

        alert('Changes saved successfully!');
        closeEditModal();
    }

    // --- Update Page Display (Called on Load and after Save) ---
    function updatePageContent() {
         // Update Header
         document.getElementById('projectTitle').textContent = projectData.title;
         document.getElementById('projectSubtitle').textContent = projectData.subtitle;
         const projectImage = document.getElementById('projectImage');
         if(projectImage) {
             projectImage.src = projectData.imageUrl;
             projectImage.alt = projectData.title + " Image"; // Update alt text
         }

         // Update Overview
         const overviewP = document.getElementById('overviewText');
         if(overviewP) overviewP.textContent = projectData.overviewText;

         // Update Learn Items
         renderLearnItems();

         // Update Video Section
         const videoIntro = document.getElementById('videoIntroText');
         const videoTitleH3 = document.getElementById('videoTitle');
         const videoIframe = document.getElementById('mainVideo');
         if(videoIntro) videoIntro.textContent = projectData.videoIntroText;
         if(videoTitleH3) videoTitleH3.textContent = projectData.videoTitle;
         if(videoIframe) videoIframe.src = projectData.videoUrl;

         const keyPointsContainer = document.getElementById('videoKeyPoints');
         if(keyPointsContainer) {
             keyPointsContainer.innerHTML = ''; // Clear existing
             if (projectData.videoKeyPoints && projectData.videoKeyPoints.length > 0) {
                 projectData.videoKeyPoints.forEach(point => {
                     const li = document.createElement('li');
                     li.textContent = point;
                     keyPointsContainer.appendChild(li);
                 });
             } else {
                 keyPointsContainer.innerHTML = '<li>Key points will appear here.</li>';
             }
         }

         // Update Slideshow
         renderSlideshow();

         // Update Challenges
         renderChallenges();

         // Update Quiz - this rerenders the whole quiz section
         renderQuiz();

         // Apply Styles (redundant if saved correctly, but safe to call)
         loadStyleSelections();
    }


    // --- Export Functionality ---
    function exportHTML() {
        console.log("Starting export...");
        try {
            // 1. Create a deep clone of the entire HTML document
            const exportDocElement = document.documentElement.cloneNode(true);
            const exportDoc = document.implementation.createHTMLDocument(projectData.title || "Export");
            exportDoc.replaceChild(exportDocElement, exportDoc.documentElement);


            // 2. Remove editor-specific elements from the clone
            exportDoc.querySelector('.edit-btn')?.remove();
            exportDoc.querySelector('.export-btn')?.remove();
            exportDoc.querySelector('#editModal')?.remove();
            console.log("Editor UI elements removed.");

            // 3. Clean up quiz state in the clone for initial view
            exportDoc.querySelectorAll('.quiz-question').forEach(qDiv => {
                qDiv.classList.remove('answered');
                qDiv.querySelectorAll('.quiz-option').forEach(opt => {
                    opt.classList.remove('selected', 'correct', 'incorrect');
                    opt.style.opacity = '1';
                    opt.style.cursor = 'pointer';
                    // Keep the onclick attribute pointing to selectQuizOption
                });
                qDiv.querySelectorAll('.quiz-feedback').forEach(fb => {
                    fb.style.display = 'none'; // Ensure feedback is hidden
                });
            });
            exportDoc.querySelector('#quizContainer .final-quiz-result')?.remove(); // Remove final result area
            const exportSubmitBtn = exportDoc.querySelector('#submitQuizBtn');
            if(exportSubmitBtn) {
                exportSubmitBtn.disabled = false; // Ensure button is enabled
                exportSubmitBtn.style.display = 'block'; // Ensure button is visible (will be hidden by render if no questions)
            }
            console.log("Quiz state cleaned.");


            // 4. Remove ALL script tags from the clone's body and head
            exportDoc.body.querySelectorAll('script').forEach(script => script.remove());
            exportDoc.head.querySelectorAll('script').forEach(script => script.remove());
            console.log("All original scripts removed.");

            // 5. Prepare and add the minimal interaction script
            const minimalScript = exportDoc.createElement('script');
            // Use template literals for easier multi-line string
            minimalScript.textContent = `
                // --- Minimal Exported Script ---
                let currentSlideIndex = 0;
                // Embed the *current* data directly into the script
                const quizDataForExport = ${JSON.stringify(quizData)};

                // --- Utility: Shuffle Array (Fisher-Yates) ---
                function shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                }

                // --- Tab Functionality ---
                function openTab(tabName, element) {
                    const tabs = document.querySelectorAll('.tab-content');
                    tabs.forEach(tab => tab.classList.remove('active'));
                    const tabButtons = document.querySelectorAll('.tab');
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    const targetTab = document.getElementById(tabName);
                    if (targetTab) targetTab.classList.add('active');
                    element?.classList.add('active');
                    updateProgressBar(tabName);
                }

                // --- Progress Bar ---
                function updateProgressBar(tab) {
                    let progress = 0;
                    const tabOrder = ['overview', 'video', 'slides', 'challenges', 'quiz'];
                    const tabIndex = tabOrder.indexOf(tab);
                    if (tabIndex >= 0) progress = ((tabIndex + 1) / tabOrder.length) * 100;
                    const progressBar = document.getElementById('progressBar');
                     if(progressBar) progressBar.style.width = progress + '%';
                }

                // --- Slideshow Functionality ---
                function showSlide(n) {
                    const slides = document.querySelectorAll('#slideshowContainer .slide');
                    const validSlidesCount = slides.length;
                    if (validSlidesCount === 0) return;
                    slides.forEach(slide => slide.classList.remove('active'));
                    currentSlideIndex = (n % validSlidesCount + validSlidesCount) % validSlidesCount; // Correct wrap-around
                    if(slides[currentSlideIndex]) slides[currentSlideIndex].classList.add('active');
                }
                function nextSlide() { showSlide(currentSlideIndex + 1); }
                function prevSlide() { showSlide(currentSlideIndex - 1); }

                // --- Quiz Interaction ---
                function selectQuizOption(optionElement) {
                    const questionDiv = optionElement.closest('.quiz-question');
                    if (!questionDiv || questionDiv.classList.contains('answered')) return;
                    const allOptions = questionDiv.querySelectorAll('.quiz-option');
                    allOptions.forEach(opt => opt.classList.remove('selected'));
                    optionElement.classList.add('selected');
                }

                function submitQuiz() {
                    const questions = document.querySelectorAll('#quizContainer .quiz-question');
                    let answeredCount = 0;
                    let score = 0;
                    const totalQuestions = questions.length;
                    if (totalQuestions === 0) return;
                    let firstUnanswered = null;

                    questions.forEach((qDiv) => {
                         const selectedOption = qDiv.querySelector('.quiz-option.selected');
                         const feedbackCorrect = qDiv.querySelector('.quiz-feedback.correct');
                         const feedbackIncorrect = qDiv.querySelector('.quiz-feedback.incorrect');
                         const allOptions = qDiv.querySelectorAll('.quiz-option');

                         // Reset feedback display first
                         if(feedbackCorrect) feedbackCorrect.style.display = 'none';
                         if(feedbackIncorrect) feedbackIncorrect.style.display = 'none';
                         qDiv.classList.remove('answered');

                         allOptions.forEach(opt => {
                             opt.classList.remove('correct', 'incorrect'); // Clear result styles before check
                             // Ensure interaction is possible if check fails
                             opt.style.opacity = '1';
                             opt.style.cursor = 'pointer';
                             opt.onclick = () => selectQuizOption(opt);
                             opt.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') selectQuizOption(opt); };
                         });

                         if (selectedOption) {
                             answeredCount++;
                         } else if (!firstUnanswered) {
                              firstUnanswered = qDiv;
                         }
                    });


                    if (answeredCount < totalQuestions) {
                         alert('Please answer all ' + totalQuestions + ' questions!');
                         if(firstUnanswered) {
                             firstUnanswered.scrollIntoView({ behavior: 'smooth', block: 'center' });
                             firstUnanswered.style.outline = '2px solid red';
                              setTimeout(() => { firstUnanswered.style.outline = 'none'; }, 2000);
                         }
                         return; // Stop submission
                    }

                     // If all answered, proceed to show results
                    questions.forEach((qDiv) => {
                         const selectedOption = qDiv.querySelector('.quiz-option.selected'); // Re-select needed data
                         const feedbackCorrect = qDiv.querySelector('.quiz-feedback.correct');
                         const feedbackIncorrect = qDiv.querySelector('.quiz-feedback.incorrect');
                         const allOptions = qDiv.querySelectorAll('.quiz-option');

                         qDiv.classList.add('answered'); // Mark as answered now for display
                         const isCorrect = selectedOption.getAttribute('data-is-correct') === 'true';

                         allOptions.forEach(opt => {
                             const optIsCorrect = opt.getAttribute('data-is-correct') === 'true';
                             if (optIsCorrect) opt.classList.add('correct');

                             if (opt.classList.contains('selected')) {
                                 if (!isCorrect) opt.classList.add('incorrect');
                             } else if (!optIsCorrect) {
                                 opt.style.opacity = "0.6"; // Dim if not selected AND not correct
                             }
                             // Disable interaction after submit
                             opt.style.cursor = "default";
                             opt.onclick = null;
                             opt.onkeydown = null;
                        });

                         if (isCorrect) {
                             score++;
                             if(feedbackCorrect) {
                                  feedbackCorrect.textContent = 'Correct!';
                                  feedbackCorrect.style.display = 'block';
                             }
                         } else {
                              if(feedbackIncorrect) {
                                   const correctOpt = qDiv.querySelector('.quiz-option.correct');
                                   feedbackIncorrect.textContent = 'Not quite. The correct answer was: "' + (correctOpt ? correctOpt.textContent : 'Error') + '".';
                                   feedbackIncorrect.style.display = 'block';
                              }
                         }
                    });


                    const submitBtn = document.getElementById('submitQuizBtn');
                    if(submitBtn) submitBtn.disabled = true;

                    const resultContainer = document.getElementById('quizContainer');
                    let resultDiv = resultContainer.querySelector('.final-quiz-result');
                     if (!resultDiv && resultContainer) { // Create if doesn't exist
                         resultDiv = document.createElement('div');
                         resultDiv.className = 'final-quiz-result';
                         resultContainer.appendChild(resultDiv);
                     }
                     if (resultDiv) {
                        resultDiv.textContent = 'Quiz Complete! You scored ' + score + ' out of ' + totalQuestions + '.';
                        resultDiv.className = 'final-quiz-result ' + ((score / totalQuestions) >= 0.7 ? 'success' : 'fail');
                        resultDiv.style.display = 'block';
                        resultDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
                     }
                }

             // --- Render Quiz From Embedded Data ---
             function renderExportedQuiz() {
                  const container = document.getElementById('quizContainer');
                  const submitBtn = document.getElementById('submitQuizBtn');
                  if (!container || !quizDataForExport) {
                        console.error("Quiz container or data missing for export render.");
                        return;
                  }
                  container.innerHTML = ''; // Clear placeholder
                   container.querySelector('.final-quiz-result')?.remove(); // Clear old results
                  submitBtn.style.display = 'none'; // Hide initially

                  const validQuestions = quizDataForExport.filter(q => q.questionText && q.questionText.trim() && q.correctAnswer && q.correctAnswer.trim());

                  if (validQuestions.length === 0) {
                      container.innerHTML = '<p>No quiz questions included.</p>';
                      return; // Keep button hidden
                  }
                  submitBtn.style.display = 'block'; // Show button if questions exist
                   submitBtn.disabled = false; // Ensure enabled

                  validQuestions.forEach((q, index) => {
                      const questionDiv = document.createElement('div');
                      questionDiv.className = 'quiz-question';
                      // questionDiv.setAttribute('data-question-index', index); // Not strictly needed in export?

                      const questionTextP = document.createElement('p');
                      questionTextP.className = 'question-text';
                      questionTextP.textContent = \`\${index + 1}. \${q.questionText}\`;
                      questionDiv.appendChild(questionTextP);

                      const optionsDiv = document.createElement('div');
                      optionsDiv.className = 'quiz-options';

                      let options = [q.correctAnswer, ...(q.incorrectAnswers || []).filter(ans => ans && ans.trim() !== '')];
                      shuffleArray(options);

                      options.forEach((optionText) => {
                          const isCorrect = (optionText === q.correctAnswer);
                          const optionEl = document.createElement('div');
                          optionEl.className = 'quiz-option';
                          optionEl.textContent = optionText;
                           optionEl.setAttribute('role', 'button');
                           optionEl.setAttribute('tabindex', '0');
                          optionEl.onclick = () => selectQuizOption(optionEl); // Assign interaction
                          optionEl.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') selectQuizOption(optionEl); };
                          optionEl.setAttribute('data-is-correct', isCorrect.toString());
                          optionsDiv.appendChild(optionEl);
                      });
                      questionDiv.appendChild(optionsDiv);

                      // Add feedback divs (hidden)
                      const feedbackCorrect = document.createElement('div');
                      feedbackCorrect.className = 'quiz-feedback correct';
                      feedbackCorrect.style.display = 'none';
                      questionDiv.appendChild(feedbackCorrect);
                      const feedbackIncorrect = document.createElement('div');
                      feedbackIncorrect.className = 'quiz-feedback incorrect';
                      feedbackIncorrect.style.display = 'none';
                      questionDiv.appendChild(feedbackIncorrect);

                      container.appendChild(questionDiv);
                  });
             }


            // --- Initial Load Logic for Exported File ---
            document.addEventListener('DOMContentLoaded', function() {
                 console.log("Exported page loaded.");
                 renderExportedQuiz(); // Render quiz using embedded data

                 const firstTabButton = document.querySelector('.tab');
                 if (firstTabButton) {
                     const firstTabName = firstTabButton.getAttribute('onclick')?.match(/openTab\\('([^']+)'/)?.[1];
                     if(firstTabName) {
                         openTab(firstTabName, firstTabButton);
                     }
                 } else {
                     // Fallback if no tabs (shouldn't happen with current structure)
                      const firstContent = document.querySelector('.tab-content');
                      if(firstContent) firstContent.classList.add('active');
                 }
                 showSlide(0); // Show first slide if slideshow exists
            });
            `; // End of minimalScript.textContent

            exportDoc.body.appendChild(minimalScript);
            console.log("Minimal script added.");

            // 6. Generate the final HTML string for download
            // Use the outerHTML of the cloned documentElement
            const htmlContent = '<!DOCTYPE html>\n' + exportDoc.documentElement.outerHTML;
            console.log("HTML content generated.");

            // 7. Create and trigger the download link
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filename = (projectData.title || "microbit-project").replace(/[^a-z0-9_.\-]/gi, '_').toLowerCase() + '.html';
            a.download = filename;
            a.style.display = 'none';

            document.body.appendChild(a);
            a.click();
            console.log("Download triggered for:", filename);

            // 8. Clean up the temporary URL and link
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log("Export cleanup complete.");
            }, 100);

        } catch (error) {
             console.error("Error during export:", error);
             alert("An error occurred during export. Please check the console for details.");
        }
    }


    // --- Utility Functions ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]]; // Swap elements
        }
    }

     // Basic color comparison (handles hex & rgb(a))
     function areColorsEqual(color1, color2) {
         try {
             // Use a temporary element to normalize colors via the browser's CSS engine
             const tempEl = document.createElement('div');
             tempEl.style.color = color1;
             const normalizedColor1 = tempEl.style.color; // Gets computed style (often rgb/rgba)
             tempEl.style.color = color2;
             const normalizedColor2 = tempEl.style.color;
             return normalizedColor1 === normalizedColor2;
         } catch (e) {
             // Fallback for invalid colors or browser issues
             return String(color1).trim().toLowerCase() === String(color2).trim().toLowerCase();
         }
     }


    // --- Initial Load ---
    document.addEventListener('DOMContentLoaded', function() {
        console.log("Editor page loaded.");
        updatePageContent(); // Load all content based on initial data

        // Set initial active tab and progress
        const firstTabButton = document.querySelector('.tab');
         if (firstTabButton) {
             const firstTabName = firstTabButton.getAttribute('onclick')?.match(/openTab\('([^']+)'/)?.[1];
             if(firstTabName) {
                 openTab(firstTabName, firstTabButton); // Activate first tab
             }
         } else {
              // Activate first content div if no tabs found
              const firstContent = document.querySelector('.tab-content');
              if (firstContent) firstContent.classList.add('active');
              updateProgressBar(''); // Set progress to 0 or default
         }
    });

</script>

</body>
</html>
